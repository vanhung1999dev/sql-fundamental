# üß† Logical SQL semantics
```sql
SELECT * 
FROM users
ORDER BY score DESC
LIMIT 10 OFFSET 20;
```

- `OFFSET 20` ‚Üí skip the first 20 rows after sorting
- `LIMIT 10` ‚Üí take the next 10 rows

Final result: <br>
```
Full result sorted ‚Üí skip 20 ‚Üí take 10
```

## üß† Naive physical execution

Without optimization: <br>

- `Scan all rows` matching WHERE/JOIN/GROUP BY.
- `Sort all rows` if ORDER BY exists (full sort if no index).
- Skip first 20 rows (OFFSET).
- Return next 10 rows.

‚úÖ Works, always correct. <br>
‚ùå Problem: For large OFFSET (e.g., 1 million), the database still processes all previous rows, which can be slow. <br>

## üß† Top-N Sort (LIMIT only, no OFFSET)
Suppose you have: <br>

```sql
SELECT *
FROM users
ORDER BY score DESC
LIMIT 10;
```

- No OFFSET ‚Üí return the top 10 rows according to score
- Database does `not need to sort the full table` if optimized

### Naive approach (without Top-N optimization)

- Scan all rows ‚Üí store all rows in memory
- Sort full result ‚Üí pick top 10
- Complexity: O(N log N)

Memory: O(N) ‚Üí can be huge for large tables <br>
‚ùå Expensive if N is large <br>

### Top-N Heap Optimization (internal mechanism)
#### Step 1 ‚Äî Initialize heap
- Empty heap of size K = 10

#### Step 2 ‚Äî Scan rows one by one
- Row 1 ‚Üí add to heap ‚Üí heap now 1 row
- Row 2 ‚Üí add ‚Üí heap size < K ‚Üí keep
- ‚Ä¶ until heap size = K

#### Step 3 ‚Äî Maintain heap
- For each new row after heap is full:
- Compare row value with smallest value in heap
- If new row > smallest ‚Üí replace smallest in heap ‚Üí maintain top K
- Else ‚Üí ignore row

#### Step 4 ‚Äî Finish scan
- After all N rows scanned ‚Üí heap contains exact top K rows

#### Step 5 ‚Äî Sort final heap
- Heap has K rows ‚Üí sort them (small memory, fast)
- Return sorted top K

##  With LIMIT + OFFSET (Top-(OFFSET+LIMIT) Heap)
```sql
SELECT *
FROM users
ORDER BY score DESC
LIMIT 10 OFFSET 20;
```

### Internal Mechanism
- Scan all rows (after WHERE/JOIN/GROUP BY)
- Keep a heap of size OFFSET + LIMIT ‚Üí here, 20 + 10 = 30
  - For DESC order: min-heap of top 30 rows
  - Maintain heap like Top-N algorithm:
    - If new row > smallest in heap ‚Üí replace
    - Else ‚Üí ignore
- After scanning all rows, heap contains top 30 rows
- Discard first 20 rows ‚Üí return next 10

Complexity: O(N log (OFFSET + LIMIT)) <br>
Memory: Heap size = OFFSET + LIMIT <br>

‚úÖ Works for correctness, but memory & heap operations grow with OFFSET

## üß†  Optimization with Index
If an index exists that matches the ORDER BY, the database can avoid full Top-N heap: <br>

```sql
CREATE INDEX idx_score_desc ON users(score DESC);
SELECT * FROM users ORDER BY score DESC LIMIT 10 OFFSET 20;
```

#### Execution:
- Scan index in sorted order
- Skip first OFFSET rows in the index (advance pointer)
- Fetch next LIMIT rows ‚Üí return

Memory usage: Only need to store LIMIT rows <br>
Complexity: O(OFFSET + LIMIT) <br>

‚ö† Still linear in OFFSET ‚Äî for very large OFFSET, still slow <br>

## üß†  Why Large OFFSET is Expensive

Even with index: <br>

- Database must walk the first OFFSET rows sequentially
- Cannot ‚Äújump‚Äù to row 1,000,001 in a B-Tree leaf without scanning previous entries
- Each step is O(1) ‚Üí total linear in OFFSET
- Memory minimal ‚Üí but time increases with OFFSET

Implication: <rb>
- OFFSET = 1,000,000 ‚Üí 1 million rows traversed ‚Üí slow query

## üß† Keyset Pagination (Recommended Alternative)
Instead of OFFSET, use WHERE clause + indexed column: <br>

```sql
SELECT *
FROM users
WHERE score < last_seen_score
ORDER BY score DESC
LIMIT 10;
```

#### Advantages:
- Directly locate rows using index ‚Üí no skipped rows
- Memory = LIMIT
- Complexity = O(LIMIT) ‚Üí constant regardless of ‚Äúpage‚Äù
- Perfect for deep pagination

#### Page 1:
```sql
SELECT * FROM users ORDER BY score DESC LIMIT 10;
```


#### Page 2
```sql
SELECT * FROM users WHERE score < 92 ORDER BY score DESC LIMIT 10;
```

- Returns next 10 rows
- Efficient for millions of rows

# Key points:

- Heap optimization works only for LIMIT
- OFFSET increases memory & time linearly
- Indexes avoid full sort, but cannot skip huge OFFSET efficiently
- Keyset pagination is the fastest for deep pages

# What ORDER BY

### ‚úî Column names
```sql
ORDER BY created_at DESC;
```

### ‚úî Aliases created in the SELECT clause
```sql
SELECT price * quantity AS total
FROM sales
ORDER BY total DESC;
```

### ‚úî Expressions
```sql
ORDER BY price * quantity;=
```

### ‚úî Column positions
```sql
SELECT id, name, age
FROM users
ORDER BY 3 DESC;  -- sorts by age
```

### Ascending vs Descending
- `ASC` ‚Üí lowest to highest (default)
- `DESC` ‚Üí highest to lowest

```sql
ORDER BY last_name ASC, first_name ASC;
```

### How SQL Handles NULL Values
Different databases treat NULL ordering differently. <br>


#### Default behavior:

MySQL / PostgreSQL
- ASC ‚Üí NULLS FIRST
- DESC ‚Üí NULLS LAST

You can control explicitly: <br>
```sql
ORDER BY created_at DESC NULLS LAST;
```

### Sorting Stability
- Sorting stability means whether equal values maintain their original order.
- SQL does NOT guarantee stable sorting unless you specify a unique tie-breaker:

```sql
------ BAD ------
ORDER BY age;


---- GOOD ----------
ORDER BY age, id;

```

### ORDER BY With GROUP BY
When grouping, you can sort by:
- grouped columns
- aggregate outputs

```sql
SELECT country, COUNT(*) AS users
FROM customers
GROUP BY country
ORDER BY users DESC;
```

### ORDER BY With LIMIT (important!)
Databases often use an optimized `‚Äútop-N‚Äù sort‚Äù`: <br>

```sql
ORDER BY score DESC
LIMIT 10;
```

This does not sort the full dataset‚Äîonly enough to determine the top 10 rows => MIN/MAX HEAP

# Performance Considerations
Sorting typically requires: <br>

- in-memory sort (fast)
- disk-based external merge sort (slow) if too large
- temp tables

Ways to improve performance: <br>

- ‚úî Sort on indexed columns
- ‚úî Ensure query reduces result set early
- ‚úî Avoid sorting huge expressions
- ‚úî Use LIMIT to reduce required sorted rows

# Short Algo

## TOP-N (using MIN/MAX HEAP)
Suppose LIMIT = 5 <br>
The engine builds a small heap (size 5). <br>

Row by row: <br>
```
1st row ‚Üí heap = [1]
2nd row ‚Üí heap = [1,2]
3rd row ‚Üí heap = [1,2,3]
...
until heap size = 5
```

Then for every new row: <br>
```
If new_row_value <= smallest_top_value:
      ignore it
Else:
      replace smallest_top_value in heap with new_row_value
```

This means:

- Only the top 5 rows are ever kept
- The rest are discarded early without sorting
- After scanning, it sorts just these 5 to produce final order

we need go through all element (n) -> take O(n) <br>
For MIN/MAX HEAP, we maintain only `k` element, for each time we only take log(k) <br>
Total time complexity: O(n log k)

## Merge sort

### In-Memory Sort

If the result fits in memory, databases use an efficient in-memory sort, typically: <br>

- Quicksort (average O(N log N))
- Heapsort (O(N log N))
- Timsort / Merge sort variant (stable, used in PostgreSQL for certain cases)

### External Sort (Disk-based)
If the data does not fit in memory, the database uses an external merge sort: <br>

- Read chunks that fit in memory ‚Üí sort them individually
- Write sorted chunks to disk
- Merge chunks in multiple passes until fully sorted

Complexity: O(N log N) <br>
More expensive than in-memory sort due to disk I/O <br>

Suppose: <br>
- Table: [8, 3, 7, 1, 9, 4, 2, 6, 5]
- Memory can hold 3 elements

#### Step 1 ‚Äî Run generation:
```
Chunk1: [8,3,7] ‚Üí sort ‚Üí [3,7,8] ‚Üí write Run1
Chunk2: [1,9,4] ‚Üí sort ‚Üí [1,4,9] ‚Üí write Run2
Chunk3: [2,6,5] ‚Üí sort ‚Üí [2,5,6] ‚Üí write Run3
```

#### Step 2 ‚Äî Merge runs:
- Multi-way merge [3,7,8], [1,4,9], [2,5,6]

Merge steps: <br>
- Pick smallest among first elements: [3,1,2] ‚Üí 1 ‚Üí output 1
- Move pointer in Run2 ‚Üí next element 4
- Pick smallest [3,4,2] ‚Üí 2 ‚Üí output 2
- Repeat until all runs exhausted ‚Üí final sorted array: [1,2,3,4,5,6,7,8,9]

# EXPLAIN QUERY

- Table: `users`
- No index on score

## üß† Case 1 ‚Äî No Index, Full Sort (LIMIT exists, but ignored by planner)
```sql
SELECT * FROM users
WHERE age > 20
ORDER BY score DESC
LIMIT 10;
```

#### Execution (EXPLAIN)
```
Seq Scan on users  (cost=0.00..2000 rows=10000 width=...)
Sort  (cost=2000..2020 rows=10000 width=...)
  Sort Key: score DESC
Limit  (cost=2020..2020 rows=10 width=...)
````

### ‚úÖ Observations:

- Sequential scan reads all rows (N rows)
- Full sort happens on all matching rows (O(N log N))
- Limit picks 10 at the end
- This is slow for large tables

## üß† Case 2 ‚Äî No Index, Top-N Heap Sort
Some databases (Postgres, MySQL 8+) can detect LIMIT and do partial top-N sort. <br>
- Conceptually same query as above
- Planner sees ORDER BY ... LIMIT 10
- Uses Top-N heapsort

#### EXPLAIN might show:
```
Seq Scan on users  (cost=0.00..2000 rows=10000 width=...)
Sort  (cost=2000..2010 rows=10 width=...)
  Sort Method: top-N heapsort  (works only because LIMIT small)
Limit  (cost=2010..2010 rows=10 width=...)
```

### ‚úÖ Observations:

- All rows are scanned (must check WHERE)
- Only top 10 rows are kept during sorting ‚Üí O(N log K)
- Limit applied logically at the end
- Faster than full sort

## üß† Case 3 ‚Äî Index Can Provide ORDER (covering index)
```sql
CREATE INDEX idx_users_score ON users(score DESC);

SELECT * FROM users
WHERE age > 20
ORDER BY score DESC
LIMIT 10;
```

#### Execution (EXPLAIN)
```sql
Index Scan using idx_users_score on users  (cost=0.15..10 rows=10 width=...)
  Filter: (age > 20)
```

### ‚úÖ Observations:

- Database can read rows already in desired order
- No sort is needed ‚Üí Sort skipped
- Limit applied during scan ‚Üí stops after 10 matching rows
- Extremely fast for large tables
- Complexity: O(K + scan cost), much better than scanning all rows

## üß† Case 4 ‚Äî Partial index + LIMIT
If index exists but does `not fully cover WHERE`: <br>

```sql
CREATE INDEX idx_users_score ON users(score DESC);
SELECT * FROM users
WHERE age > 30
ORDER BY score DESC
LIMIT 10;
```

- Index exists for score, but filtering on age
- DB can scan index, but may need to skip non-matching rows

#### EXPLAIN might show:
```
Index Scan using idx_users_score on users  (cost=0.15..20 rows=10 width=...)
  Filter: (age > 30)
```

### ‚úÖ Observations:

- DB walks index in order, applies filter
- Keeps track of top N matches ‚Üí limit stops scan early
- Still faster than full table scan, but may read more than N rows if filter rejects many

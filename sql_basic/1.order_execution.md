✅ SQL Logical Query Processing Order (FROM → SELECT)

## Here is the correct order that every SQL query follows `LOGICAL`:

### 1. FROM
- Pick the main table(s).
- Apply aliases.
- Do all joins.

### 2. ON
- Apply join conditions for each JOIN.

### 3. JOIN
- Combine tables (INNER, LEFT, RIGHT, FULL).

### 4. WHERE
- Filter rows before grouping.
- Cannot use aggregate functions in WHERE.

### 5. GROUP BY
- Group rows into buckets.
- Prepare for aggregates.

### 6. HAVING

- Filter groups after aggregation.
- Can use SUM(), COUNT(), AVG(), etc.

### 7. SELECT

- Select columns.
- Compute expressions.
- Apply aliases (aliases become available only here).

### 8. DISTINCT

- Remove duplicates from the SELECT result.

### 9. ORDER BY
- Sort rows.
- Can use SELECT aliases.

### 10. LIMIT / OFFSET

- Return only a specific number of rows.

## Rules for Logical Query Execution Order
This is defined by the SQL standard — it tells you how SQL should be interpreted. The database must produce the same result if you respect these rules, regardless of optimization. <br>

Logical processing order: <br>

- `FROM` – identify the tables involved
- `ON` – join conditions for multiple tables
- `JOIN` – combine tables
- `WHERE` – filter rows
- `GROUP BY` – form groups
- `HAVING` – filter groups
- `SELECT` – choose columns or expressions
- `DISTINCT` – remove duplicates
- `WINDOW FUNCTIONS` – compute analytic functions
- `ORDER BY` – sort results
- `LIMIT / OFFSET / FETCH` – limit rows

#### Rules/Implications:

- You cannot reference a column in WHERE that doesn’t exist yet.
- Aggregate functions must be used after GROUP BY.
- You cannot use ORDER BY before aggregation; it happens after SELECT.
- This order is fixed in conceptual evaluation, though you don’t write it in that sequence.

## Physical Query Execution Order (PQEO)
Physical order = how the `database engine actually executes the query internally`. <br>
This order is determined by the `query optimizer and often differs completely from the logical order` <br>

### 2.1 Parsing

- Tokenizes SQL text.
- Validates syntax.
- Validates tables, columns, datatypes.
- Builds an abstract syntax tree (AST).

### 2.2 Query Rewriting (Rule-Based)

The engine improves the query before optimization: <br>

- Predicate pushdown
- Constant folding
- Subquery unnesting
- View expansion
- Removing redundant filters

### 2.3 Cost-Based Optimization

Optimizer evaluates many possible physical plans using: <br>

- Index statistics
- Histograms
- Table cardinality
- CPU + I/O cost

Memory requirements <br>

- Parallelism options
- Decisions include:
- Access path (index seek, index scan, table scan)
- Join algorithm (nested loop, hash join, merge join)
- Join order (A join B vs B join A)
- Filter application location (pushdown)
- Sort, aggregate, parallel operations

### 2.4 Plan Generation

Optimizer chooses the lowest-cost plan and outputs operators such as: <br>

- TABLE SCAN
- INDEX SEEK
- FILTER
- HASH JOIN
- NESTED LOOP
- MERGE JOIN
- SORT
- AGGREGATE
- LIMIT

### 2.5 Execution Engine (Iterator / Volcano Model)

- Operators run in a pipeline.
- Each operator asks its child operator for the next row.
- Data flows upward until the final result is produced.

## Rules for Physical Execution Order
General Principles / Rules: <br>

- `Pushdown Filters`
  - Apply WHERE as early as possible to reduce row count.

- `Use Indexes When Available`
  - Scan tables using indexes rather than full table scans if it is cheaper.

- `Join Reordering`
  - Engine may reorder joins based on table sizes, statistics, and costs.

- `Choose Best Join Algorithm`
  - Nested-loop, hash join, or merge join based on row counts and indexing.

- `Cost-Based Decisions`
  - Every plan has a cost estimated using I/O, CPU, memory, and statistics. The optimizer picks the lowest cost.

- `Pipeline Execution`
  - Rows flow from lower operators to higher operators; parent operators pull rows from child operators.

- `Short-Circuit / Early Exit`
  - Limit/Top can stop execution early once enough rows are returned.

- `Parallelism / Partitioning`
  - Some engines can split tasks across threads or partitions.

#### Key difference:
- Logical rules guarantee correct results.
- Physical rules guarantee performance, but results must still respect logical order.

## Example Simple Filter

```sql
SELECT * FROM Orders WHERE customer_id = 5;
```

#### Logical Order

```
FROM → WHERE → SELECT
```

#### Physical Order (Example)

```
- Index seek on customer_id
- Fetch matching rows
- Return rows
```
=> Physical execution applies the WHERE filter before scanning the table if an index exists.

## Example: JOIN

```sql
SELECT *
FROM A
JOIN B ON A.id = B.a_id;
```

### Logical Order

```
FROM A → JOIN B → ON → SELECT
```

### Physical Order (Example)

- Optimizer may swap join order (start with B instead of A)
- May choose:
    - HASH JOIN
    - MERGE JOIN
    - NESTED LOOP
- May push filters into each table before join
- May use indexes on either table

=> Physical execution does not follow the SQL text order.

# Final Summary

Logical execution describes how SQL should be interpreted. <br>
Physical execution describes how the query is actually run internally. <br>
The optimizer: <br>

- Reorders joins
- Pushes down filters
- Chooses best access paths
- Chooses join algorithms
- Uses indexes and statistics

=> `Physical execution almost never matches the logical order.`
